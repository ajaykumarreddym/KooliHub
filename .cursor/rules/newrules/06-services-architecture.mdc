---
description: Service Layer Architecture - API Services & Data Access
globs: **/*.ts,**/*.tsx
---

# Service Layer Architecture

## Overview
Proper organization of API services, data access layers, and external integrations following Clean Architecture principles.

---

## 1. Service Layer Structure

```
client/
├── services/                    # API Service Layer
│   ├── api/                     # REST API services
│   │   ├── base-api.ts          # Base API client
│   │   ├── products-api.ts
│   │   ├── orders-api.ts
│   │   ├── vendors-api.ts
│   │   └── auth-api.ts
│   │
│   ├── supabase/               # Supabase services
│   │   ├── products-service.ts
│   │   ├── orders-service.ts
│   │   └── realtime-service.ts
│   │
│   └── external/               # Third-party services
│       ├── maps-service.ts
│       ├── payment-service.ts
│       └── notification-service.ts
│
├── domain/                     # Domain Layer (Business Logic)
│   ├── entities/
│   ├── repositories/
│   └── services/
│
└── infrastructure/             # Infrastructure Layer
    └── repositories/
```

---

## 2. Base API Client

### 2.1 Base API Service
```typescript
// client/services/api/base-api.ts

import { API_CONFIG, TIMEOUTS } from '@/lib/constants';

interface RequestConfig extends RequestInit {
  timeout?: number;
  params?: Record<string, string | number | boolean>;
}

interface ApiResponse<T> {
  data: T | null;
  error: string | null;
  status: number;
}

class BaseApi {
  private baseUrl: string;

  constructor(baseUrl: string = API_CONFIG.baseUrl) {
    this.baseUrl = baseUrl;
  }

  /**
   * Build URL with query params
   */
  private buildUrl(endpoint: string, params?: Record<string, any>): string {
    const url = new URL(endpoint, this.baseUrl);
    
    if (params) {
      Object.entries(params).forEach(([key, value]) => {
        if (value !== undefined && value !== null) {
          url.searchParams.append(key, String(value));
        }
      });
    }
    
    return url.toString();
  }

  /**
   * Get auth headers
   */
  private async getAuthHeaders(): Promise<Record<string, string>> {
    const { supabase } = await import('@/lib/supabase');
    const { data: { session } } = await supabase.auth.getSession();
    
    const headers: Record<string, string> = {
      'Content-Type': 'application/json',
    };
    
    if (session?.access_token) {
      headers['Authorization'] = `Bearer ${session.access_token}`;
    }
    
    return headers;
  }

  /**
   * Make HTTP request with timeout
   */
  private async request<T>(
    endpoint: string,
    config: RequestConfig = {}
  ): Promise<ApiResponse<T>> {
    const {
      timeout = TIMEOUTS.api,
      params,
      ...fetchConfig
    } = config;

    const url = this.buildUrl(endpoint, params);
    const authHeaders = await this.getAuthHeaders();

    // Create abort controller for timeout
    const controller = new AbortController();
    const timeoutId = setTimeout(() => controller.abort(), timeout);

    try {
      const response = await fetch(url, {
        ...fetchConfig,
        headers: {
          ...authHeaders,
          ...fetchConfig.headers,
        },
        signal: controller.signal,
      });

      clearTimeout(timeoutId);

      const data = await response.json();

      if (!response.ok) {
        return {
          data: null,
          error: data.message || data.error || 'Request failed',
          status: response.status,
        };
      }

      return {
        data: data.data || data,
        error: null,
        status: response.status,
      };
    } catch (error) {
      clearTimeout(timeoutId);

      if (error instanceof Error) {
        if (error.name === 'AbortError') {
          return {
            data: null,
            error: 'Request timeout',
            status: 408,
          };
        }
        return {
          data: null,
          error: error.message,
          status: 500,
        };
      }

      return {
        data: null,
        error: 'Unknown error occurred',
        status: 500,
      };
    }
  }

  // HTTP Methods
  async get<T>(endpoint: string, params?: Record<string, any>): Promise<ApiResponse<T>> {
    return this.request<T>(endpoint, { method: 'GET', params });
  }

  async post<T>(endpoint: string, body?: any): Promise<ApiResponse<T>> {
    return this.request<T>(endpoint, {
      method: 'POST',
      body: JSON.stringify(body),
    });
  }

  async put<T>(endpoint: string, body?: any): Promise<ApiResponse<T>> {
    return this.request<T>(endpoint, {
      method: 'PUT',
      body: JSON.stringify(body),
    });
  }

  async patch<T>(endpoint: string, body?: any): Promise<ApiResponse<T>> {
    return this.request<T>(endpoint, {
      method: 'PATCH',
      body: JSON.stringify(body),
    });
  }

  async delete<T>(endpoint: string): Promise<ApiResponse<T>> {
    return this.request<T>(endpoint, { method: 'DELETE' });
  }
}

export const api = new BaseApi();
export default BaseApi;
```

---

## 3. Feature API Services

### 3.1 Products API Service
```typescript
// client/services/api/products-api.ts

import { api } from './base-api';
import type { Product, ApiResponse, PaginatedResponse } from '@shared/api';

interface ProductFilters {
  category?: string;
  vendor?: string;
  minPrice?: number;
  maxPrice?: number;
  search?: string;
  page?: number;
  limit?: number;
}

export const productsApi = {
  /**
   * Get products with filters
   */
  getProducts: async (filters?: ProductFilters) => {
    return api.get<PaginatedResponse<Product>>('/products', filters);
  },

  /**
   * Get single product
   */
  getProduct: async (id: string) => {
    return api.get<Product>(`/products/${id}`);
  },

  /**
   * Create product (admin)
   */
  createProduct: async (data: Partial<Product>) => {
    return api.post<Product>('/products', data);
  },

  /**
   * Update product (admin)
   */
  updateProduct: async (id: string, data: Partial<Product>) => {
    return api.put<Product>(`/products/${id}`, data);
  },

  /**
   * Delete product (admin)
   */
  deleteProduct: async (id: string) => {
    return api.delete<void>(`/products/${id}`);
  },

  /**
   * Search products
   */
  searchProducts: async (query: string, limit: number = 20) => {
    return api.get<Product[]>('/products/search', { q: query, limit });
  },
};
```

### 3.2 Orders API Service
```typescript
// client/services/api/orders-api.ts

import { api } from './base-api';
import type { Order, OrderStatus } from '@shared/api';

interface CreateOrderData {
  items: Array<{ productId: string; quantity: number }>;
  addressId: string;
  paymentMethod: string;
  notes?: string;
}

export const ordersApi = {
  /**
   * Get user orders
   */
  getOrders: async (status?: OrderStatus) => {
    return api.get<Order[]>('/orders', { status });
  },

  /**
   * Get single order
   */
  getOrder: async (id: string) => {
    return api.get<Order>(`/orders/${id}`);
  },

  /**
   * Create order
   */
  createOrder: async (data: CreateOrderData) => {
    return api.post<Order>('/orders', data);
  },

  /**
   * Cancel order
   */
  cancelOrder: async (id: string, reason?: string) => {
    return api.post<Order>(`/orders/${id}/cancel`, { reason });
  },

  /**
   * Track order
   */
  trackOrder: async (id: string) => {
    return api.get<{ status: OrderStatus; timeline: any[] }>(`/orders/${id}/track`);
  },
};
```

---

## 4. Supabase Services

### 4.1 Products Supabase Service
```typescript
// client/services/supabase/products-service.ts

import { supabase } from '@/lib/supabase';
import type { Product } from '@shared/api';

interface ProductFilters {
  category?: string;
  vendorId?: string;
  serviceType?: string;
  isActive?: boolean;
  search?: string;
  limit?: number;
  offset?: number;
}

export const productsService = {
  /**
   * Get products with filters
   */
  async getProducts(filters: ProductFilters = {}) {
    let query = supabase
      .from('offerings')
      .select(`
        *,
        vendor:vendors(id, name, logo_url),
        category:categories(id, name)
      `)
      .is('deleted_at', null)
      .eq('is_active', true);

    // Apply filters
    if (filters.category) {
      query = query.eq('category_id', filters.category);
    }
    if (filters.vendorId) {
      query = query.eq('vendor_id', filters.vendorId);
    }
    if (filters.serviceType) {
      query = query.eq('type', filters.serviceType);
    }
    if (filters.search) {
      query = query.ilike('name', `%${filters.search}%`);
    }

    // Pagination
    if (filters.limit) {
      query = query.limit(filters.limit);
    }
    if (filters.offset) {
      query = query.range(filters.offset, filters.offset + (filters.limit || 20) - 1);
    }

    // Order
    query = query.order('created_at', { ascending: false });

    const { data, error, count } = await query;

    if (error) throw error;
    return { data, count };
  },

  /**
   * Get single product
   */
  async getProduct(id: string) {
    const { data, error } = await supabase
      .from('offerings')
      .select(`
        *,
        vendor:vendors(*),
        category:categories(*),
        variants:offering_variants(*),
        attributes:offering_attributes(
          *,
          attribute_registry(*)
        )
      `)
      .eq('id', id)
      .single();

    if (error) throw error;
    return data;
  },

  /**
   * Create product
   */
  async createProduct(product: Partial<Product>) {
    const { data, error } = await supabase
      .from('offerings')
      .insert(product)
      .select()
      .single();

    if (error) throw error;
    return data;
  },

  /**
   * Update product
   */
  async updateProduct(id: string, updates: Partial<Product>) {
    const { data, error } = await supabase
      .from('offerings')
      .update({ ...updates, updated_at: new Date().toISOString() })
      .eq('id', id)
      .select()
      .single();

    if (error) throw error;
    return data;
  },

  /**
   * Soft delete product
   */
  async deleteProduct(id: string) {
    const { error } = await supabase
      .from('offerings')
      .update({ deleted_at: new Date().toISOString() })
      .eq('id', id);

    if (error) throw error;
  },

  /**
   * Search products (with full-text search)
   */
  async searchProducts(query: string, limit: number = 20) {
    const { data, error } = await supabase
      .from('offerings')
      .select('id, name, image_url, price, vendor:vendors(name)')
      .is('deleted_at', null)
      .eq('is_active', true)
      .or(`name.ilike.%${query}%,description.ilike.%${query}%`)
      .limit(limit);

    if (error) throw error;
    return data;
  },
};
```

### 4.2 Realtime Service
```typescript
// client/services/supabase/realtime-service.ts

import { supabase } from '@/lib/supabase';
import { RealtimeChannel } from '@supabase/supabase-js';

type ChangeHandler = (payload: any) => void;

class RealtimeService {
  private channels: Map<string, RealtimeChannel> = new Map();

  /**
   * Subscribe to table changes
   */
  subscribe(
    table: string,
    event: 'INSERT' | 'UPDATE' | 'DELETE' | '*',
    callback: ChangeHandler,
    filter?: { column: string; value: string }
  ): () => void {
    const channelName = `${table}-${event}-${filter?.value || 'all'}`;

    // Remove existing subscription
    if (this.channels.has(channelName)) {
      this.unsubscribe(channelName);
    }

    const channel = supabase
      .channel(channelName)
      .on(
        'postgres_changes',
        {
          event,
          schema: 'public',
          table,
          ...(filter && { filter: `${filter.column}=eq.${filter.value}` }),
        },
        callback
      )
      .subscribe();

    this.channels.set(channelName, channel);

    // Return cleanup function
    return () => this.unsubscribe(channelName);
  }

  /**
   * Unsubscribe from channel
   */
  unsubscribe(channelName: string): void {
    const channel = this.channels.get(channelName);
    if (channel) {
      supabase.removeChannel(channel);
      this.channels.delete(channelName);
    }
  }

  /**
   * Unsubscribe from all channels
   */
  unsubscribeAll(): void {
    this.channels.forEach((channel, name) => {
      supabase.removeChannel(channel);
    });
    this.channels.clear();
  }

  /**
   * Subscribe to order updates for user
   */
  subscribeToOrders(userId: string, callback: ChangeHandler): () => void {
    return this.subscribe('orders', '*', callback, {
      column: 'user_id',
      value: userId,
    });
  }

  /**
   * Subscribe to product inventory changes
   */
  subscribeToInventory(productId: string, callback: ChangeHandler): () => void {
    return this.subscribe('merchant_inventory', 'UPDATE', callback, {
      column: 'offering_id',
      value: productId,
    });
  }
}

export const realtimeService = new RealtimeService();
```

---

## 5. External Services

### 5.1 Maps Service
```typescript
// client/services/external/maps-service.ts

import { MAPS_CONFIG } from '@/lib/config';

export interface GeoLocation {
  lat: number;
  lng: number;
}

export interface GeocodeResult {
  address: string;
  city: string;
  state: string;
  pincode: string;
  coordinates: GeoLocation;
}

export const mapsService = {
  /**
   * Get user's current location
   */
  getCurrentLocation(): Promise<GeoLocation> {
    return new Promise((resolve, reject) => {
      if (!navigator.geolocation) {
        reject(new Error('Geolocation is not supported'));
        return;
      }

      navigator.geolocation.getCurrentPosition(
        (position) => {
          resolve({
            lat: position.coords.latitude,
            lng: position.coords.longitude,
          });
        },
        (error) => {
          reject(error);
        },
        {
          enableHighAccuracy: true,
          timeout: 5000,
          maximumAge: 0,
        }
      );
    });
  },

  /**
   * Reverse geocode coordinates to address
   */
  async reverseGeocode(location: GeoLocation): Promise<GeocodeResult | null> {
    try {
      const response = await fetch(
        `https://nominatim.openstreetmap.org/reverse?` +
        `format=json&lat=${location.lat}&lon=${location.lng}`
      );
      
      const data = await response.json();
      
      return {
        address: data.display_name,
        city: data.address.city || data.address.town || data.address.village,
        state: data.address.state,
        pincode: data.address.postcode,
        coordinates: location,
      };
    } catch (error) {
      console.error('Reverse geocode failed:', error);
      return null;
    }
  },

  /**
   * Search for location by query
   */
  async searchLocation(query: string): Promise<GeocodeResult[]> {
    try {
      const response = await fetch(
        `https://nominatim.openstreetmap.org/search?` +
        `format=json&q=${encodeURIComponent(query)}&countrycodes=in&limit=5`
      );
      
      const data = await response.json();
      
      return data.map((item: any) => ({
        address: item.display_name,
        city: item.address?.city || item.address?.town,
        state: item.address?.state,
        pincode: item.address?.postcode,
        coordinates: {
          lat: parseFloat(item.lat),
          lng: parseFloat(item.lon),
        },
      }));
    } catch (error) {
      console.error('Location search failed:', error);
      return [];
    }
  },

  /**
   * Calculate distance between two points (km)
   */
  calculateDistance(from: GeoLocation, to: GeoLocation): number {
    const R = 6371; // Earth's radius in km
    const dLat = this.toRad(to.lat - from.lat);
    const dLng = this.toRad(to.lng - from.lng);
    
    const a =
      Math.sin(dLat / 2) * Math.sin(dLat / 2) +
      Math.cos(this.toRad(from.lat)) * Math.cos(this.toRad(to.lat)) *
      Math.sin(dLng / 2) * Math.sin(dLng / 2);
    
    const c = 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1 - a));
    
    return R * c;
  },

  toRad(deg: number): number {
    return deg * (Math.PI / 180);
  },
};
```

### 5.2 Notification Service
```typescript
// client/services/external/notification-service.ts

import { FIREBASE_CONFIG } from '@/lib/config';

export interface NotificationPayload {
  title: string;
  body: string;
  icon?: string;
  data?: Record<string, any>;
}

export const notificationService = {
  /**
   * Request notification permission
   */
  async requestPermission(): Promise<boolean> {
    if (!('Notification' in window)) {
      console.warn('Notifications not supported');
      return false;
    }

    const permission = await Notification.requestPermission();
    return permission === 'granted';
  },

  /**
   * Check if notifications are enabled
   */
  isEnabled(): boolean {
    return 'Notification' in window && Notification.permission === 'granted';
  },

  /**
   * Show local notification
   */
  showNotification(payload: NotificationPayload): void {
    if (!this.isEnabled()) return;

    new Notification(payload.title, {
      body: payload.body,
      icon: payload.icon || '/icons/notification-icon.png',
      data: payload.data,
    });
  },

  /**
   * Get FCM token (requires Firebase setup)
   */
  async getFCMToken(): Promise<string | null> {
    try {
      const { getMessaging, getToken } = await import('firebase/messaging');
      const { initializeApp } = await import('firebase/app');
      
      const app = initializeApp(FIREBASE_CONFIG);
      const messaging = getMessaging(app);
      
      const token = await getToken(messaging, {
        vapidKey: FIREBASE_CONFIG.vapidKey,
      });
      
      return token;
    } catch (error) {
      console.error('Failed to get FCM token:', error);
      return null;
    }
  },
};
```

---

## 6. Service Usage Patterns

### 6.1 Using in Hooks
```typescript
// client/hooks/use-products.ts

import { useQuery, useMutation, useQueryClient } from '@tanstack/react-query';
import { productsService } from '@/services/supabase/products-service';
import { useToast } from '@/hooks/use-toast';
import { MESSAGES } from '@/lib/strings';

export function useProducts(filters?: ProductFilters) {
  return useQuery({
    queryKey: ['products', filters],
    queryFn: () => productsService.getProducts(filters),
  });
}

export function useProduct(id: string) {
  return useQuery({
    queryKey: ['product', id],
    queryFn: () => productsService.getProduct(id),
    enabled: !!id,
  });
}

export function useCreateProduct() {
  const queryClient = useQueryClient();
  const { toast } = useToast();

  return useMutation({
    mutationFn: productsService.createProduct,
    onSuccess: () => {
      queryClient.invalidateQueries({ queryKey: ['products'] });
      toast({ title: MESSAGES.success.created });
    },
    onError: () => {
      toast({ title: MESSAGES.error.generic, variant: 'destructive' });
    },
  });
}
```

### 6.2 Using with Real-time
```typescript
// In a component
import { useEffect } from 'react';
import { realtimeService } from '@/services/supabase/realtime-service';

function OrderTracking({ orderId }: { orderId: string }) {
  useEffect(() => {
    const unsubscribe = realtimeService.subscribe(
      'orders',
      'UPDATE',
      (payload) => {
        console.log('Order updated:', payload);
        // Handle update
      },
      { column: 'id', value: orderId }
    );

    return () => unsubscribe();
  }, [orderId]);

  return <div>...</div>;
}
```

---

## 7. Rules Summary

### DO:
- ✅ Create separate service files for each domain
- ✅ Use typed responses and parameters
- ✅ Handle errors consistently
- ✅ Use singleton pattern for service instances
- ✅ Clean up subscriptions on unmount

### DON'T:
- ❌ Call Supabase directly in components
- ❌ Duplicate API logic across files
- ❌ Hardcode API endpoints
- ❌ Ignore error handling
- ❌ Leave subscriptions open

---

**Related Files**:
- `client/services/api/` - API services
- `client/services/supabase/` - Supabase services
- `client/services/external/` - Third-party services
