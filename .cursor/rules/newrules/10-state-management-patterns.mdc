---
description: State Management Patterns - Context, Hooks, and React Query
globs: **/*.tsx,**/*.ts
---

# State Management Patterns

## Overview
Comprehensive state management strategy using React Context for global state, React Query for server state, and local state patterns.

---

## 1. State Management Architecture

### 1.1 State Categories
```
State Types
├── Server State (React Query)
│   ├── API data
│   ├── Database records
│   └── External data
│
├── Global Client State (Context)
│   ├── Auth state
│   ├── User preferences
│   ├── Theme
│   └── Location
│
├── Feature State (Context per feature)
│   ├── Cart
│   ├── Wishlist
│   └── Admin data
│
└── Local Component State (useState)
    ├── Form state
    ├── UI state (modals, dropdowns)
    └── Derived/computed values
```

### 1.2 Decision Matrix
```typescript
// When to use each state type

// React Query - For server state
// - Data from APIs/database
// - Needs caching, refetching, background updates
// - Shared across multiple components

// Context - For global client state
// - User authentication
// - App-wide settings/preferences
// - Feature-specific state (cart, wishlist)

// useState - For local state
// - Form inputs
// - UI toggles (open/closed)
// - Component-specific data
// - Derived values

// useReducer - For complex local state
// - Multiple related state values
// - Complex state transitions
// - When useState becomes unwieldy
```

---

## 2. Context Pattern Templates

### 2.1 Base Context Template
```typescript
// client/contexts/ExampleContext.tsx

import React, { createContext, useContext, useState, useCallback, useMemo, ReactNode } from 'react';

// ═══════════════════════════════════════════
// TYPES
// ═══════════════════════════════════════════
interface ExampleState {
  items: Item[];
  isLoading: boolean;
  error: string | null;
}

interface ExampleContextValue extends ExampleState {
  // Actions
  addItem: (item: Item) => void;
  removeItem: (id: string) => void;
  clearItems: () => void;
  // Computed
  itemCount: number;
  isEmpty: boolean;
}

// ═══════════════════════════════════════════
// CONTEXT
// ═══════════════════════════════════════════
const ExampleContext = createContext<ExampleContextValue | undefined>(undefined);

// ═══════════════════════════════════════════
// PROVIDER
// ═══════════════════════════════════════════
interface ExampleProviderProps {
  children: ReactNode;
  initialItems?: Item[];
}

export function ExampleProvider({ children, initialItems = [] }: ExampleProviderProps) {
  // State
  const [items, setItems] = useState<Item[]>(initialItems);
  const [isLoading, setIsLoading] = useState(false);
  const [error, setError] = useState<string | null>(null);

  // Actions - memoized to prevent unnecessary re-renders
  const addItem = useCallback((item: Item) => {
    setItems(prev => [...prev, item]);
  }, []);

  const removeItem = useCallback((id: string) => {
    setItems(prev => prev.filter(item => item.id !== id));
  }, []);

  const clearItems = useCallback(() => {
    setItems([]);
  }, []);

  // Computed values
  const itemCount = useMemo(() => items.length, [items]);
  const isEmpty = itemCount === 0;

  // Memoize context value to prevent unnecessary re-renders
  const value = useMemo<ExampleContextValue>(() => ({
    items,
    isLoading,
    error,
    addItem,
    removeItem,
    clearItems,
    itemCount,
    isEmpty,
  }), [items, isLoading, error, addItem, removeItem, clearItems, itemCount, isEmpty]);

  return (
    <ExampleContext.Provider value={value}>
      {children}
    </ExampleContext.Provider>
  );
}

// ═══════════════════════════════════════════
// HOOK
// ═══════════════════════════════════════════
export function useExample() {
  const context = useContext(ExampleContext);
  
  if (context === undefined) {
    throw new Error('useExample must be used within an ExampleProvider');
  }
  
  return context;
}

// Export specific parts of context for selective usage
export function useExampleItems() {
  const { items, addItem, removeItem } = useExample();
  return { items, addItem, removeItem };
}

export function useExampleStatus() {
  const { isLoading, error } = useExample();
  return { isLoading, error };
}
```

### 2.2 Auth Context (Real Example)
```typescript
// client/contexts/AuthContext.tsx

import React, { createContext, useContext, useEffect, useState, useCallback, useMemo, ReactNode } from 'react';
import { User, Session } from '@supabase/supabase-js';
import { supabase } from '@/lib/supabase';
import type { Profile } from '@shared/api';

interface AuthContextValue {
  user: User | null;
  profile: Profile | null;
  session: Session | null;
  isLoading: boolean;
  isAuthenticated: boolean;
  isAdmin: boolean;
  signIn: (email: string, password: string) => Promise<void>;
  signUp: (email: string, password: string, name: string) => Promise<void>;
  signOut: () => Promise<void>;
  refreshProfile: () => Promise<void>;
}

const AuthContext = createContext<AuthContextValue | undefined>(undefined);

export function AuthProvider({ children }: { children: ReactNode }) {
  const [user, setUser] = useState<User | null>(null);
  const [profile, setProfile] = useState<Profile | null>(null);
  const [session, setSession] = useState<Session | null>(null);
  const [isLoading, setIsLoading] = useState(true);

  // Fetch profile for user
  const fetchProfile = useCallback(async (userId: string) => {
    const { data } = await supabase
      .from('profiles')
      .select('*')
      .eq('id', userId)
      .single();
    
    setProfile(data);
    return data;
  }, []);

  // Initialize auth state
  useEffect(() => {
    // Get initial session
    supabase.auth.getSession().then(({ data: { session } }) => {
      setSession(session);
      setUser(session?.user ?? null);
      if (session?.user) {
        fetchProfile(session.user.id);
      }
      setIsLoading(false);
    });

    // Listen for auth changes
    const { data: { subscription } } = supabase.auth.onAuthStateChange(
      async (event, session) => {
        setSession(session);
        setUser(session?.user ?? null);
        
        if (session?.user) {
          await fetchProfile(session.user.id);
        } else {
          setProfile(null);
        }
      }
    );

    return () => subscription.unsubscribe();
  }, [fetchProfile]);

  // Auth actions
  const signIn = useCallback(async (email: string, password: string) => {
    const { error } = await supabase.auth.signInWithPassword({ email, password });
    if (error) throw error;
  }, []);

  const signUp = useCallback(async (email: string, password: string, name: string) => {
    const { error } = await supabase.auth.signUp({
      email,
      password,
      options: { data: { full_name: name } },
    });
    if (error) throw error;
  }, []);

  const signOut = useCallback(async () => {
    const { error } = await supabase.auth.signOut();
    if (error) throw error;
  }, []);

  const refreshProfile = useCallback(async () => {
    if (user) {
      await fetchProfile(user.id);
    }
  }, [user, fetchProfile]);

  // Computed
  const isAuthenticated = !!user;
  const isAdmin = profile?.role === 'admin';

  const value = useMemo<AuthContextValue>(() => ({
    user,
    profile,
    session,
    isLoading,
    isAuthenticated,
    isAdmin,
    signIn,
    signUp,
    signOut,
    refreshProfile,
  }), [
    user, profile, session, isLoading, isAuthenticated, isAdmin,
    signIn, signUp, signOut, refreshProfile
  ]);

  return (
    <AuthContext.Provider value={value}>
      {children}
    </AuthContext.Provider>
  );
}

export function useAuth() {
  const context = useContext(AuthContext);
  if (!context) {
    throw new Error('useAuth must be used within AuthProvider');
  }
  return context;
}
```

### 2.3 Cart Context (Real Example)
```typescript
// client/contexts/CartContext.tsx

import React, { createContext, useContext, useEffect, useState, useCallback, useMemo, ReactNode } from 'react';
import { storage, STORAGE_KEYS } from '@/lib/storage-utils';

interface CartItem {
  id: string;
  productId: string;
  name: string;
  price: number;
  quantity: number;
  image?: string;
}

interface CartContextValue {
  items: CartItem[];
  addItem: (item: Omit<CartItem, 'id'>) => void;
  removeItem: (id: string) => void;
  updateQuantity: (id: string, quantity: number) => void;
  clearCart: () => void;
  // Computed
  totalItems: number;
  totalPrice: number;
  isEmpty: boolean;
  getItemQuantity: (productId: string) => number;
}

const CartContext = createContext<CartContextValue | undefined>(undefined);

export function CartProvider({ children }: { children: ReactNode }) {
  const [items, setItems] = useState<CartItem[]>(() => {
    // Initialize from localStorage
    return storage.getStorageItem<CartItem[]>(STORAGE_KEYS.CART, []);
  });

  // Persist to localStorage
  useEffect(() => {
    storage.setStorageItem(STORAGE_KEYS.CART, items);
  }, [items]);

  const addItem = useCallback((item: Omit<CartItem, 'id'>) => {
    setItems(prev => {
      const existing = prev.find(i => i.productId === item.productId);
      if (existing) {
        return prev.map(i =>
          i.productId === item.productId
            ? { ...i, quantity: i.quantity + item.quantity }
            : i
        );
      }
      return [...prev, { ...item, id: crypto.randomUUID() }];
    });
  }, []);

  const removeItem = useCallback((id: string) => {
    setItems(prev => prev.filter(item => item.id !== id));
  }, []);

  const updateQuantity = useCallback((id: string, quantity: number) => {
    if (quantity <= 0) {
      setItems(prev => prev.filter(item => item.id !== id));
    } else {
      setItems(prev => prev.map(item =>
        item.id === id ? { ...item, quantity } : item
      ));
    }
  }, []);

  const clearCart = useCallback(() => {
    setItems([]);
  }, []);

  // Computed
  const totalItems = useMemo(() => 
    items.reduce((sum, item) => sum + item.quantity, 0), 
  [items]);

  const totalPrice = useMemo(() => 
    items.reduce((sum, item) => sum + (item.price * item.quantity), 0), 
  [items]);

  const isEmpty = items.length === 0;

  const getItemQuantity = useCallback((productId: string) => {
    const item = items.find(i => i.productId === productId);
    return item?.quantity ?? 0;
  }, [items]);

  const value = useMemo<CartContextValue>(() => ({
    items,
    addItem,
    removeItem,
    updateQuantity,
    clearCart,
    totalItems,
    totalPrice,
    isEmpty,
    getItemQuantity,
  }), [
    items, addItem, removeItem, updateQuantity, clearCart,
    totalItems, totalPrice, isEmpty, getItemQuantity
  ]);

  return (
    <CartContext.Provider value={value}>
      {children}
    </CartContext.Provider>
  );
}

export function useCart() {
  const context = useContext(CartContext);
  if (!context) {
    throw new Error('useCart must be used within CartProvider');
  }
  return context;
}
```

---

## 3. React Query Patterns

### 3.1 Query Hooks Pattern
```typescript
// client/hooks/queries/use-products.ts

import { useQuery, useMutation, useQueryClient, useInfiniteQuery } from '@tanstack/react-query';
import { productsService } from '@/services/supabase/products-service';
import { CACHE } from '@/lib/constants';

// Query keys factory
export const productKeys = {
  all: ['products'] as const,
  lists: () => [...productKeys.all, 'list'] as const,
  list: (filters: ProductFilters) => [...productKeys.lists(), filters] as const,
  details: () => [...productKeys.all, 'detail'] as const,
  detail: (id: string) => [...productKeys.details(), id] as const,
};

// List query
export function useProducts(filters?: ProductFilters) {
  return useQuery({
    queryKey: productKeys.list(filters || {}),
    queryFn: () => productsService.getProducts(filters),
    staleTime: CACHE.staleTime,
  });
}

// Detail query
export function useProduct(id: string | undefined) {
  return useQuery({
    queryKey: productKeys.detail(id!),
    queryFn: () => productsService.getProduct(id!),
    enabled: !!id,
  });
}

// Infinite scroll query
export function useInfiniteProducts(filters?: ProductFilters) {
  return useInfiniteQuery({
    queryKey: productKeys.list({ ...filters, infinite: true }),
    queryFn: ({ pageParam = 0 }) => productsService.getProducts({
      ...filters,
      offset: pageParam,
      limit: 20,
    }),
    getNextPageParam: (lastPage, pages) => {
      return lastPage.data?.length === 20 ? pages.length * 20 : undefined;
    },
    initialPageParam: 0,
  });
}

// Mutations
export function useCreateProduct() {
  const queryClient = useQueryClient();

  return useMutation({
    mutationFn: productsService.createProduct,
    onSuccess: () => {
      queryClient.invalidateQueries({ queryKey: productKeys.lists() });
    },
  });
}

export function useUpdateProduct() {
  const queryClient = useQueryClient();

  return useMutation({
    mutationFn: ({ id, data }: { id: string; data: Partial<Product> }) =>
      productsService.updateProduct(id, data),
    onSuccess: (data, { id }) => {
      queryClient.invalidateQueries({ queryKey: productKeys.detail(id) });
      queryClient.invalidateQueries({ queryKey: productKeys.lists() });
    },
  });
}

export function useDeleteProduct() {
  const queryClient = useQueryClient();

  return useMutation({
    mutationFn: productsService.deleteProduct,
    onSuccess: () => {
      queryClient.invalidateQueries({ queryKey: productKeys.lists() });
    },
  });
}
```

### 3.2 Prefetching Pattern
```typescript
// Prefetch on hover
function ProductLink({ productId, children }: { productId: string; children: ReactNode }) {
  const queryClient = useQueryClient();

  const prefetchProduct = () => {
    queryClient.prefetchQuery({
      queryKey: productKeys.detail(productId),
      queryFn: () => productsService.getProduct(productId),
      staleTime: CACHE.prefetchStaleTime,
    });
  };

  return (
    <Link 
      to={`/products/${productId}`}
      onMouseEnter={prefetchProduct}
      onFocus={prefetchProduct}
    >
      {children}
    </Link>
  );
}
```

### 3.3 Optimistic Updates Pattern
```typescript
export function useToggleFavorite() {
  const queryClient = useQueryClient();

  return useMutation({
    mutationFn: ({ productId, isFavorite }: { productId: string; isFavorite: boolean }) =>
      api.post(`/products/${productId}/favorite`, { isFavorite }),
    
    // Optimistic update
    onMutate: async ({ productId, isFavorite }) => {
      // Cancel outgoing refetches
      await queryClient.cancelQueries({ queryKey: productKeys.detail(productId) });
      
      // Snapshot previous value
      const previousProduct = queryClient.getQueryData(productKeys.detail(productId));
      
      // Optimistically update
      queryClient.setQueryData(productKeys.detail(productId), (old: any) => ({
        ...old,
        isFavorite,
      }));
      
      return { previousProduct };
    },
    
    // Rollback on error
    onError: (err, { productId }, context) => {
      queryClient.setQueryData(
        productKeys.detail(productId),
        context?.previousProduct
      );
    },
    
    // Refetch on settle
    onSettled: (data, error, { productId }) => {
      queryClient.invalidateQueries({ queryKey: productKeys.detail(productId) });
    },
  });
}
```

---

## 4. Local State Patterns

### 4.1 Form State Hook
```typescript
// client/hooks/use-form-state.ts

import { useState, useCallback } from 'react';

interface FormState<T> {
  values: T;
  errors: Partial<Record<keyof T, string>>;
  touched: Partial<Record<keyof T, boolean>>;
  isSubmitting: boolean;
}

export function useFormState<T extends Record<string, any>>(initialValues: T) {
  const [state, setState] = useState<FormState<T>>({
    values: initialValues,
    errors: {},
    touched: {},
    isSubmitting: false,
  });

  const setValue = useCallback(<K extends keyof T>(field: K, value: T[K]) => {
    setState(prev => ({
      ...prev,
      values: { ...prev.values, [field]: value },
      touched: { ...prev.touched, [field]: true },
    }));
  }, []);

  const setError = useCallback(<K extends keyof T>(field: K, error: string) => {
    setState(prev => ({
      ...prev,
      errors: { ...prev.errors, [field]: error },
    }));
  }, []);

  const setErrors = useCallback((errors: Partial<Record<keyof T, string>>) => {
    setState(prev => ({ ...prev, errors }));
  }, []);

  const reset = useCallback(() => {
    setState({
      values: initialValues,
      errors: {},
      touched: {},
      isSubmitting: false,
    });
  }, [initialValues]);

  const setSubmitting = useCallback((isSubmitting: boolean) => {
    setState(prev => ({ ...prev, isSubmitting }));
  }, []);

  return {
    ...state,
    setValue,
    setError,
    setErrors,
    reset,
    setSubmitting,
  };
}
```

### 4.2 Toggle State Hook
```typescript
// client/hooks/use-toggle.ts

import { useState, useCallback } from 'react';

export function useToggle(initialValue: boolean = false) {
  const [value, setValue] = useState(initialValue);

  const toggle = useCallback(() => setValue(v => !v), []);
  const setTrue = useCallback(() => setValue(true), []);
  const setFalse = useCallback(() => setValue(false), []);

  return { value, toggle, setTrue, setFalse, setValue };
}

// Usage
const { value: isOpen, toggle, setFalse: close } = useToggle();
```

### 4.3 Disclosure Hook (Modal/Dialog)
```typescript
// client/hooks/use-disclosure.ts

import { useState, useCallback } from 'react';

interface UseDisclosureReturn {
  isOpen: boolean;
  open: () => void;
  close: () => void;
  toggle: () => void;
  onOpenChange: (open: boolean) => void;
}

export function useDisclosure(initialState: boolean = false): UseDisclosureReturn {
  const [isOpen, setIsOpen] = useState(initialState);

  const open = useCallback(() => setIsOpen(true), []);
  const close = useCallback(() => setIsOpen(false), []);
  const toggle = useCallback(() => setIsOpen(prev => !prev), []);
  const onOpenChange = useCallback((open: boolean) => setIsOpen(open), []);

  return { isOpen, open, close, toggle, onOpenChange };
}

// Usage with Dialog
const deleteDialog = useDisclosure();

<Button onClick={deleteDialog.open}>Delete</Button>
<AlertDialog open={deleteDialog.isOpen} onOpenChange={deleteDialog.onOpenChange}>
  ...
</AlertDialog>
```

---

## 5. Provider Hierarchy

### 5.1 App Provider Setup
```typescript
// client/App.tsx - Provider hierarchy

function App() {
  return (
    <React.StrictMode>
      {/* External providers */}
      <QueryClientProvider client={queryClient}>
        {/* Auth must be first for other providers to access user */}
        <AuthProvider>
          {/* Admin data depends on auth */}
          <AdminDataProvider>
            {/* Firebase for notifications */}
            <FirebaseProvider>
              {/* Location for serviceability */}
              <LocationProvider>
                {/* User features */}
                <WishlistProvider>
                  <CartProvider>
                    {/* UI providers */}
                    <TooltipProvider>
                      <Toaster />
                      <Sonner />
                      {/* Router */}
                      <BrowserRouter>
                        <Routes>
                          {/* ... routes */}
                        </Routes>
                      </BrowserRouter>
                    </TooltipProvider>
                  </CartProvider>
                </WishlistProvider>
              </LocationProvider>
            </FirebaseProvider>
          </AdminDataProvider>
        </AuthProvider>
      </QueryClientProvider>
    </React.StrictMode>
  );
}
```

---

## 6. Rules Summary

### DO:
- ✅ Use React Query for server state
- ✅ Use Context for global client state
- ✅ Memoize context values with useMemo
- ✅ Memoize callbacks with useCallback
- ✅ Create custom hooks for context access
- ✅ Use query key factories
- ✅ Implement optimistic updates for better UX

### DON'T:
- ❌ Put server state in Context
- ❌ Create context without memoization
- ❌ Pass functions as context values without useCallback
- ❌ Use multiple useState when useReducer is cleaner
- ❌ Prop drill when context is appropriate

---

**Related Files**:
- `client/contexts/` - Context providers
- `client/hooks/` - Custom hooks
- `client/lib/query-client.ts` - React Query setup
